import os
from datetime import datetime, timedelta, timezone
import jwt
import uuid
import getpass
from dotenv import load_dotenv
import yaml
import logging
from typing import Dict, Optional, Tuple

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

# Configuration
JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", "dev-secret-key")
JWT_ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRES_HOURS = int(os.getenv("ACCESS_TOKEN_EXPIRES_HOURS", "1"))
REFRESH_TOKEN_EXPIRES_DAYS = int(os.getenv("REFRESH_TOKEN_EXPIRES_DAYS", "30"))
API_KEYS_DIR = os.getenv("API_KEYS_DIR", "config/api_keys")
BASE_API_KEY_FILE = "base_api_key.yaml"
ALWAYS_USE_BASE_CLAIMS = os.getenv("ALWAYS_USE_BASE_CLAIMS", "true").lower() == "true"

class JWTGenerator:
    def __init__(self):
        self.api_keys_dir = API_KEYS_DIR
        os.makedirs(self.api_keys_dir, exist_ok=True)
        
        # Load base API key claims if exists
        self.base_api_key_claims = self._load_base_api_key_claims()

    def _load_base_api_key_claims(self) -> Dict:
        """Load claims from base API key file if it exists"""
        base_key_path = os.path.join(self.api_keys_dir, BASE_API_KEY_FILE)
        if os.path.exists(base_key_path):
            try:
                with open(base_key_path, 'r') as f:
                    key_data = yaml.safe_load(f)
                return key_data.get('claims', {}).get('static', {})
            except Exception as e:
                logger.error(f"Error loading base API key: {e}")
        return {}

    def authenticate_user(self, username: str, password: str) -> Tuple[bool, Dict]:
        """
        Authenticate user (simplified version - in production use proper auth backend)
        Returns tuple of (authenticated, user_data)
        """
        # This is a simplified version. In production, you would:
        # 1. Use a proper authentication backend (LDAP, database, etc.)
        # 2. Store password hashes, not plain text
        # 3. Implement proper error handling and logging
        
        # Example user database
        users = {
            "admin": {
                "password": "admin123",  # In production, store hashed passwords
                "email": "admin@example.com",
                "groups": ["administrators"],
                "roles": ["admin"],
                "team_id": "admin-team"
            },
            "user": {
                "password": "password123",
                "email": "user@example.com",
                "groups": ["users"],
                "roles": ["user"],
                "team_id": "general-users"
            }
        }
        
        user = users.get(username)
        if user and user["password"] == password:
            user_data = {
                "user_id": username,
                "email": user["email"],
                "groups": user["groups"],
                "roles": user["roles"],
                "team_id": user["team_id"]
            }
            return True, user_data
        
        return False, {"error": "Invalid username or password"}

    def get_additional_claims(self, api_key: Optional[str], user_context: Dict) -> Dict:
        """
        Get additional claims from API key configuration
        """
        claims = {}
        
        # Always include base claims if configured
        if ALWAYS_USE_BASE_CLAIMS and self.base_api_key_claims:
            claims.update(self.base_api_key_claims)
        
        # If no API key provided, just return base claims (if any)
        if not api_key:
            return claims
        
        # Look for API key file
        api_key_file = os.path.join(self.api_keys_dir, f"{api_key}.yaml")
        if not os.path.exists(api_key_file):
            logger.warning(f"API key not found: {api_key}")
            return claims
        
        try:
            with open(api_key_file, 'r') as f:
                key_data = yaml.safe_load(f)
            
            # Add static claims
            static_claims = key_data.get('claims', {}).get('static', {})
            claims.update(static_claims)
            
            # Process dynamic claims (simplified version)
            dynamic_claims = key_data.get('claims', {}).get('dynamic', {})
            for claim_key, claim_value in dynamic_claims.items():
                # Simple dynamic claim processing based on user context
                if isinstance(claim_value, str):
                    if claim_value.startswith("user."):
                        field = claim_value[5:]
                        claims[claim_key] = user_context.get(field)
                    elif claim_value.startswith("env."):
                        var_name = claim_value[4:]
                        claims[claim_key] = os.getenv(var_name)
            
            return claims
        
        except Exception as e:
            logger.error(f"Error processing API key {api_key}: {e}")
            return claims

    def generate_tokens(self, username: str, user_data: Dict, api_key: Optional[str] = None, custom_secret: Optional[str] = None) -> Dict:
        """
        Generate JWT tokens with optional API key claims and custom secret
        """
        # Create user context for dynamic claims
        user_context = {
            "user_id": username,
            "email": user_data.get("email", ""),
            "groups": user_data.get("groups", []),
            "roles": user_data.get("roles", []),
            "team_id": user_data.get("team_id", "general-users")
        }
        
        # Get additional claims from API key
        api_key_claims = self.get_additional_claims(api_key, user_context)
        
        # Merge user data with additional claims
        claims = {**user_data, **api_key_claims}
        
        # Get expiration time from claims if specified
        expires_delta = timedelta(hours=ACCESS_TOKEN_EXPIRES_HOURS)
        if 'exp_hours' in claims:
            expires_delta = timedelta(hours=claims['exp_hours'])
            logger.info(f"Using custom expiration time: {claims['exp_hours']} hours")
            claims.pop('exp_hours')
        
        now = datetime.now(timezone.utc)
        access_token_exp = now + expires_delta
        refresh_token_exp = now + timedelta(days=REFRESH_TOKEN_EXPIRES_DAYS)
        
        # Access token payload
        access_payload = {
            "iat": now,
            "nbf": now,
            "jti": str(uuid.uuid4()),
            "exp": access_token_exp,
            "sub": username,
            "type": "access",
            "fresh": True,
            **claims
        }
        
        # Refresh token payload
        refresh_payload = {
            "iat": now,
            "nbf": now,
            "jti": str(uuid.uuid4()),
            "exp": refresh_token_exp,
            "sub": username,
            "type": "refresh",
            **claims
        }
        
        # Determine which secret to use
        secret_key = custom_secret if custom_secret else JWT_SECRET_KEY
        
        # Generate tokens
        access_token = jwt.encode(access_payload, secret_key, algorithm=JWT_ALGORITHM)
        refresh_token = jwt.encode(refresh_payload, secret_key, algorithm=JWT_ALGORITHM)
        
        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "access_token_expires": access_token_exp.isoformat(),
            "refresh_token_expires": refresh_token_exp.isoformat(),
            "note": "Tokens generated with custom secret" if custom_secret else None
        }

    def decode_token(self, token: str, custom_secret: Optional[str] = None, skip_verification: bool = False) -> Dict:
        """
        Decode a JWT token with optional custom secret and verification skipping
        """
        secret_key = custom_secret if custom_secret else JWT_SECRET_KEY
        
        try:
            if skip_verification:
                decoded = jwt.decode(token, options={"verify_signature": False})
                decoded["warning"] = "Token signature verification was skipped!"
                return decoded
            
            decoded = jwt.decode(token, secret_key, algorithms=[JWT_ALGORITHM])
            if custom_secret:
                decoded["note"] = "Decoded using provided custom secret"
            return decoded
        except Exception as e:
            raise ValueError(f"Token decoding failed: {str(e)}")

def main():
    print("Production JWT Token Generator")
    print("=" * 50)
    
    generator = JWTGenerator()
    
    # Get user input
    username = input("Enter username: ").strip()
    password = getpass.getpass("Enter password: ").strip()
    api_key = input("Enter API key (optional, press Enter to skip): ").strip() or None
    custom_secret = getpass.getpass("Enter custom secret (optional, press Enter to use default): ").strip() or None
    
    # Authenticate
    authenticated, user_data = generator.authenticate_user(username, password)
    if not authenticated:
        print(f"\nAuthentication failed: {user_data.get('error', 'Unknown error')}")
        return
    
    # Generate tokens
    try:
        tokens = generator.generate_tokens(username, user_data, api_key, custom_secret)
        
        print("\nToken Generation Successful!")
        print(f"\nAccess Token (expires at {tokens['access_token_expires']}):")
        print(tokens["access_token"])
        
        print(f"\nRefresh Token (expires at {tokens['refresh_token_expires']}):")
        print(tokens["refresh_token"])
        
        if tokens.get("note"):
            print(f"\nNote: {tokens['note']}")
        
        # Option to decode token
        decode_choice = input("\nWould you like to decode the access token? (y/n): ").lower()
        if decode_choice == 'y':
            try:
                decoded = generator.decode_token(tokens["access_token"], custom_secret)
                print("\nDecoded Access Token:")
                for key, value in decoded.items():
                    print(f"{key}: {value}")
            except ValueError as e:
                print(f"\nError decoding token: {e}")
                
                # Try unverified decode
                unverified_choice = input("Would you like to decode without verification? (y/n): ").lower()
                if unverified_choice == 'y':
                    try:
                        decoded = generator.decode_token(tokens["access_token"], skip_verification=True)
                        print("\nUnverified Decoded Access Token:")
                        for key, value in decoded.items():
                            print(f"{key}: {value}")
                    except ValueError as e:
                        print(f"\nError in unverified decode: {e}")
    
    except Exception as e:
        print(f"\nError generating tokens: {str(e)}")

if __name__ == "__main__":
    main()
