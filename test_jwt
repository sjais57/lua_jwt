group_Category.py:

import logging
from typing import List, Dict, Any
import subprocess
import tempfile
import json
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

OPA_POLICY_PATH = os.environ.get(
    "OPA_POLICY_PATH",
    "policies/clients/group_category.rego"  # Update as needed
)

def get_user_category(user_groups: List[str], lookup_mode: str = 'TIERED_MATCH', **kwargs) -> Dict[str, Any]:
    """
    Assign user to a category by calling OPA (Open Policy Agent) with group membership and metadata.

    Args:
        user_groups: List of groups the user belongs to
        lookup_mode: Only 'TIERED_MATCH' supported for OPA use
        metadata: (kwarg) metadata dictionary containing 'categories'
    Returns:
        Dict with category assignment result (for JWT claims)
    """
    metadata = kwargs.get('metadata', {})
    opa_input = {
        "user_groups": user_groups,
        "metadata": metadata
    }

    # Write input to a temporary file
    with tempfile.NamedTemporaryFile("w+", suffix=".json", delete=False) as tf:
        json.dump(opa_input, tf)
        tf.flush()
        input_path = tf.name

    try:
        # Call OPA CLI with policy file and input
        cmd = [
            "opa", "eval",
            "--data", OPA_POLICY_PATH,
            "--input", input_path,
            "--format", "json",
            "data.dspai.policy"
        ]
        logger.info(f"Calling OPA: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            logger.error(f"OPA evaluation failed: {result.stderr}")
            return {"category": None, "match_mode": lookup_mode, "reason": f"OPA error: {result.stderr}"}
        opa_result = json.loads(result.stdout)

        # Extract matched_category from OPA output
        matched_category = None
        if "result" in opa_result and len(opa_result["result"]) > 0:
            expressions = opa_result["result"][0].get("expressions", [])
            for expr in expressions:
                value = expr.get("value", {})
                if isinstance(value, dict) and "matched_category" in value:
                    matched_category = value["matched_category"]

        if matched_category:
            return {"category": matched_category, "match_mode": lookup_mode}
        else:
            return {"category": None, "match_mode": lookup_mode, "reason": "No match (OPA)"}
    except Exception as e:
        logger.error(f"OPA evaluation failed: {e}")
        return {"category": None, "match_mode": lookup_mode, "reason": f"Exception: {e}"}
    finally:
        if os.path.exists(input_path):
            os.unlink(input_path)




group_category.rego:
package dspai.policy

default matched_category = null

matches[c] {
    some name
    cat := input.metadata.categories[name]
    some g
    g := input.user_groups[_]
    g == cat.groups[_]
    c := {
        "name": name,
        "tier": cat.tier,
        "destURL": cat.destURL
    }
}

matched_category = best {
    cats := [c | c := matches[_]]
    count(cats) > 0
    best := max(cats, compare)
}

compare(a, b) = r {
    r := a.tier > b.tier
}
