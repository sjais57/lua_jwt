import logging
from typing import List, Dict, Any
import subprocess
import tempfile
import json
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_user_category(user_groups: List[str], lookup_mode: str = 'TIERED_MATCH', **kwargs) -> Dict[str, Any]:
    """
    Assign user to a category using ONLY the OPA policy embedded in metadata['opa_policy'].
    Args:
        user_groups: List of user's groups
        lookup_mode: Only 'TIERED_MATCH' supported
        metadata: (kwarg) metadata dict with 'categories' and 'opa_policy'
    Returns:
        Dict with category assignment result
    """
    metadata = kwargs.get('metadata', {})
    opa_input = {
        "user_groups": user_groups,
        "metadata": metadata
    }

    opa_policy_code = metadata.get("opa_policy")
    if not opa_policy_code:
        raise ValueError("No 'opa_policy' field in metadata. This function requires a policy in every YAML!")

    # Write OPA policy code to a temp file
    with tempfile.NamedTemporaryFile("w+", suffix=".rego", delete=False) as pf:
        pf.write(opa_policy_code)
        pf.flush()
        opa_policy_path = pf.name

    # Write input to a temporary file
    with tempfile.NamedTemporaryFile("w+", suffix=".json", delete=False) as tf:
        json.dump(opa_input, tf)
        tf.flush()
        input_path = tf.name

    try:
        cmd = [
            "opa", "eval",
            "--data", opa_policy_path,
            "--input", input_path,
            "--format", "json",
            "data.dspai.policy"
        ]
        logger.info(f"Calling OPA: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            logger.error(f"OPA evaluation failed: {result.stderr}")
            return {"category": None, "match_mode": lookup_mode, "reason": f"OPA error: {result.stderr}"}
        opa_result = json.loads(result.stdout)

        # Extract matched_category from OPA output
        matched_category = None
        if "result" in opa_result and len(opa_result["result"]) > 0:
            expressions = opa_result["result"][0].get("expressions", [])
            for expr in expressions:
                value = expr.get("value", {})
                if isinstance(value, dict) and "matched_category" in value:
                    matched_category = value["matched_category"]

        if matched_category:
            return {"category": matched_category, "match_mode": lookup_mode}
        else:
            return {"category": None, "match_mode": lookup_mode, "reason": "No match (OPA)"}
    except Exception as e:
        logger.error(f"OPA evaluation failed: {e}")
        return {"category": None, "match_mode": lookup_mode, "reason": f"Exception: {e}"}
    finally:
        if os.path.exists(input_path):
            os.unlink(input_path)
        if os.path.exists(opa_policy_path):
            os.unlink(opa_policy_path)
==============================================================================
import logging
from typing import List, Dict, Any
import subprocess
import tempfile
import json
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_user_category(user_groups: List[str], lookup_mode: str = 'FIRST_MATCH', **kwargs) -> Dict[str, Any]:
    """
    Assign user to a category using OPA if policy is present, else fallback to default Python logic.
    Args:
        user_groups: List of groups the user belongs to
        lookup_mode: 'FIRST_MATCH', 'ALL_MATCHES', or 'TIERED_MATCH'
        metadata: (kwarg) metadata dict with 'categories' and optionally 'opa_policy'
    Returns:
        Dict with category assignment result
    """
    metadata = kwargs.get('metadata', {})
    opa_policy_code = metadata.get("opa_policy")

    # ---- OPA logic if policy is present ----
    if opa_policy_code:
        opa_input = {
            "user_groups": user_groups,
            "metadata": metadata
        }
        # Write OPA policy to a temp file
        with tempfile.NamedTemporaryFile("w+", suffix=".rego", delete=False) as pf:
            pf.write(opa_policy_code)
            pf.flush()
            opa_policy_path = pf.name
        # Write input to temp file
        with tempfile.NamedTemporaryFile("w+", suffix=".json", delete=False) as tf:
            json.dump(opa_input, tf)
            tf.flush()
            input_path = tf.name
        try:
            cmd = [
                "opa", "eval",
                "--data", opa_policy_path,
                "--input", input_path,
                "--format", "json",
                "data.dspai.policy"
            ]
            logger.info(f"Calling OPA: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode != 0:
                logger.error(f"OPA evaluation failed: {result.stderr}")
                return {"category": None, "match_mode": lookup_mode, "reason": f"OPA error: {result.stderr}"}
            opa_result = json.loads(result.stdout)
            # Extract matched_category from OPA output
            matched_category = None
            if "result" in opa_result and len(opa_result["result"]) > 0:
                expressions = opa_result["result"][0].get("expressions", [])
                for expr in expressions:
                    value = expr.get("value", {})
                    if isinstance(value, dict) and "matched_category" in value:
                        matched_category = value["matched_category"]
            if matched_category:
                return {"category": matched_category, "match_mode": lookup_mode}
            else:
                return {"category": None, "match_mode": lookup_mode, "reason": "No match (OPA)"}
        except Exception as e:
            logger.error(f"OPA evaluation failed: {e}")
            return {"category": None, "match_mode": lookup_mode, "reason": f"Exception: {e}"}
        finally:
            if os.path.exists(input_path):
                os.unlink(input_path)
            if os.path.exists(opa_policy_path):
                os.unlink(opa_policy_path)

    # ---- Pure Python fallback logic ----
    logger.info(f"Assigning user category for groups: {user_groups} with mode: {lookup_mode}")
    categories = metadata.get('categories', {})
    if not categories:
        logger.warning("No categories found in metadata")
        return {"categories": [], "match_mode": lookup_mode, "reason": "No categories in metadata"}

    matches = []
    for cat_name, cat_data in categories.items():
        cat_groups = cat_data.get('groups', [])
        if any(g in user_groups for g in cat_groups):
            matches.append({"name": cat_name, **cat_data})

    if lookup_mode == 'FIRST_MATCH':
        if matches:
            return {"category": matches[0], "match_mode": lookup_mode}
        else:
            return {"category": None, "match_mode": lookup_mode, "reason": "No match"}
    elif lookup_mode == 'ALL_MATCHES':
        return {"categories": matches, "match_mode": lookup_mode}
    elif lookup_mode == 'TIERED_MATCH':
        if matches:
            best = max(matches, key=lambda x: x.get('tier', 0))
            return {"category": best, "match_mode": lookup_mode}
        else:
            return {"category": None, "match_mode": lookup_mode, "reason": "No match"}
    else:
        logger.warning(f"Unknown lookup_mode: {lookup_mode}")
        return {"categories": matches, "match_mode": lookup_mode, "reason": "Unknown lookup_mode"}


===============================================================
import logging
from typing import List, Dict, Any
import subprocess
import tempfile
import json
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_user_category(user_groups: List[str], lookup_mode: str = 'TIERED_MATCH', **kwargs) -> Dict[str, Any]:
    """
    Assign user to a category using OPA with policy code from metadata (if present).
    Args:
        user_groups: List of user's groups
        lookup_mode: Only 'TIERED_MATCH' supported for OPA use
        metadata: (kwarg) metadata dict with 'categories' and optionally 'opa_policy'
    Returns:
        Dict with category assignment result
    """
    metadata = kwargs.get('metadata', {})
    opa_input = {
        "user_groups": user_groups,
        "metadata": metadata
    }

    # OPA policy: from metadata['opa_policy'] if present, else fallback to file
    opa_policy_code = metadata.get("opa_policy")
    if opa_policy_code:
        # Write OPA policy code to a temp file
        with tempfile.NamedTemporaryFile("w+", suffix=".rego", delete=False) as pf:
            pf.write(opa_policy_code)
            pf.flush()
            opa_policy_path = pf.name
    else:
        opa_policy_path = os.environ.get(
            "OPA_POLICY_PATH",
            "policies/clients/group_category.rego"
        )

    # Write input to a temporary file
    with tempfile.NamedTemporaryFile("w+", suffix=".json", delete=False) as tf:
        json.dump(opa_input, tf)
        tf.flush()
        input_path = tf.name

    try:
        cmd = [
            "opa", "eval",
            "--data", opa_policy_path,
            "--input", input_path,
            "--format", "json",
            "data.dspai.policy"
        ]
        logger.info(f"Calling OPA: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            logger.error(f"OPA evaluation failed: {result.stderr}")
            return {"category": None, "match_mode": lookup_mode, "reason": f"OPA error: {result.stderr}"}
        opa_result = json.loads(result.stdout)

        # Extract matched_category from OPA output
        matched_category = None
        if "result" in opa_result and len(opa_result["result"]) > 0:
            expressions = opa_result["result"][0].get("expressions", [])
            for expr in expressions:
                value = expr.get("value", {})
                if isinstance(value, dict) and "matched_category" in value:
                    matched_category = value["matched_category"]

        if matched_category:
            return {"category": matched_category, "match_mode": lookup_mode}
        else:
            return {"category": None, "match_mode": lookup_mode, "reason": "No match (OPA)"}
    except Exception as e:
        logger.error(f"OPA evaluation failed: {e}")
        return {"category": None, "match_mode": lookup_mode, "reason": f"Exception: {e}"}
    finally:
        if os.path.exists(input_path):
            os.unlink(input_path)
        if opa_policy_code and os.path.exists(opa_policy_path):
            os.unlink(opa_policy_path)
