import logging
from typing import List, Dict, Any

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_user_category(user_configs: List[str], lookup_mode: str = 'FIRST_MATCH', **kwargs) -> Dict[str, Any]:
    """
    Assign user to a category based on 'configs' field in metadata and lookup mode.

    Args:
        user_configs: List of configs associated with the user (e.g., from claims["configuration_name"])
        lookup_mode: 'FIRST_MATCH', 'ALL_MATCHES', or 'TIERED_MATCH'
        metadata: (kwarg) metadata dictionary (apikey config format)
    Returns:
        Dict with category assignment result
    """
    logger.info(f"Assigning user category for configs: {user_configs} with mode: {lookup_mode}")
    metadata = kwargs.get('metadata', {})
    
    if not metadata:
        logger.warning("No metadata provided")
        return {"categories": [], "match_mode": lookup_mode, "reason": "No metadata provided"}

    matches = []
    for cat_name, cat_data in metadata.items():
        cat_configs = cat_data.get('configs', [])
        if any(conf in user_configs for conf in cat_configs):
            matches.append({"name": cat_name, **cat_data})

    if lookup_mode == 'FIRST_MATCH':
        return {
            "category": matches[0] if matches else None,
            "match_mode": lookup_mode,
            "reason": None if matches else "No match"
        }

    elif lookup_mode == 'ALL_MATCHES':
        return {
            "categories": matches,
            "match_mode": lookup_mode
        }

    elif lookup_mode == 'TIERED_MATCH':
        best = max(matches, key=lambda x: x.get('tier', 0), default=None)
        return {
            "category": best,
            "match_mode": lookup_mode,
            "reason": None if best else "No match"
        }

    else:
        logger.warning(f"Unknown lookup_mode: {lookup_mode}")
        return {
            "categories": matches,
            "match_mode": lookup_mode,
            "reason": "Unknown lookup_mode"
        }
