def get_model_map_info(allowed_path: str) -> Dict[str, Any]:
    catalog = load_model_catalog()
    subtree: Any = catalog

    # Safely descend through the path
    for key in allowed_path.split("#"):
        if not isinstance(subtree, dict):
            return {}
        subtree = subtree.get(key)
        if subtree is None:
            return {}

    # If subtree is the configs list directly
    configs = subtree if isinstance(subtree, list) else subtree.get("configs", [])
    
    result: Dict[str, Any] = {}

    for cfg in configs:
        name = cfg.get("unique_model_name")
        if not name:
            continue
        result.setdefault(name, {
            "model_name": name,
            "frameworks": []
        })["frameworks"].append({
            "supported_framework": f"{cfg.get('inference_type', '')}_{cfg.get('protocol', '')}",
            "protocol": cfg.get("protocol", ""),
            "script_name": cfg.get("script_name", ""),
            "hpc_model_name": cfg.get("hpc_model_name", ""),
            "tasks": cfg.get("tasks", ""),
        })

    return result




======
# ── extract allowed_models from the Rego policy ──────────────────────────────
pattern = r'allowed_models\s*:=\s*\[\s*([^\]]+)\]'
match   = re.search(pattern, policy_content)
allowed_model_list = [
    s.strip().strip('"').strip("'")              # remove spaces + quotes
    for s in match.group(1).split(",")           # comma-separated list
    if s.strip()                                 # skip empty fragments
]

# ── build OpenAI-style response for each path ────────────────────────────────
allowed_models = []
for path in allowed_model_list:                  # ← each item is a full #-path
    model_map = get_model_map_info(path)         # grouped by unique_model_name
    for model_name, model_data in model_map.items():
        allowed_models.append({
            "model": model_name,
            **model_data
        })

return JSONResponse({"allowed_models": allowed_models})

