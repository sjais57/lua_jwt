def flatten_models(node, ancestry=None, allowed_model_list=None, model_info_map=None):
    if ancestry is None:
        ancestry = {}
    if model_info_map is None:
        model_info_map = {}

    # Base case: config node (leaf)
    if isinstance(node, dict) and "unique_model_name" in node:
        unique_model_name = node.get("unique_model_name", "")
        if allowed_model_list and unique_model_name not in allowed_model_list:
            return model_info_map
        framework_entry = {
            k: (str(v) if k == "tasks" and v is not None else v)
            for k, v in node.items()
            if k in {"supported_framework", "tasks", "script_name", "hpc_model_name"}
        }
        if unique_model_name not in model_info_map:
            model_info_map[unique_model_name] = {
                "model_name": unique_model_name,
                **ancestry,
                "frameworks": []
            }
        model_info_map[unique_model_name]["frameworks"].append(framework_entry)
        return model_info_map

    # Recursive case: dict (process children)
    if isinstance(node, dict):
        for key, value in node.items():
            new_ancestry = ancestry.copy()
            # Dynamically store label if the node has 'name'
            if isinstance(node, dict) and "name" in node:
                new_ancestry[key] = node.get("name", "")
            if isinstance(value, list):
                for item in value:
                    flatten_models(item, new_ancestry, allowed_model_list, model_info_map)
            elif isinstance(value, dict):
                flatten_models(value, new_ancestry, allowed_model_list, model_info_map)
    # Recursive case: list
    elif isinstance(node, list):
        for item in node:
            flatten_models(item, ancestry, allowed_model_list, model_info_map)

    return model_info_map
=============================



def flatten_models(node, ancestry=None, allowed_model_list=None, model_info_map=None):
    """
    Recursively traverses a nested model catalog to extract all model configurations.
    
    Args:
        node: Current node in the dictionary (starts at root).
        ancestry: Dict of parent keys (e.g., {"model_type": "llm", "family": "research"}).
        allowed_model_list: Optional allowlist of model names to include.
        model_info_map: Accumulator for results.
    
    Returns:
        Dict of model info, keyed by unique_model_name.
    """
    if ancestry is None:
        ancestry = {}
    if model_info_map is None:
        model_info_map = {}

    # Base case: Found a model config node
    if isinstance(node, dict) and "unique_model_name" in node:
        unique_model_name = node.get("unique_model_name")
        if not unique_model_name:
            return model_info_map
        
        # Skip if not in allowlist
        if allowed_model_list and unique_model_name not in allowed_model_list:
            return model_info_map
        
        # Extract framework fields (with validation)
        framework_entry = {
            "supported_framework": node.get("supported_framework", ""),
            "tasks": str(node.get("tasks", "")) if node.get("tasks") is not None else "",
            "script_name": node.get("script_name", ""),
            "hpc_model_name": node.get("hpc_model_name", "")
        }

        # Initialize model entry if new
        if unique_model_name not in model_info_map:
            model_info_map[unique_model_name] = {
                "model_name": unique_model_name,
                **ancestry,  # Inherit parent context (e.g., model_type, family)
                "frameworks": []
            }
        
        model_info_map[unique_model_name]["frameworks"].append(framework_entry)
        return model_info_map

    # Recursive case: Process children
    if isinstance(node, dict):
        new_ancestry = ancestry.copy()
        # Track named parent nodes (e.g., model_type, family)
        if "name" in node and "key" in node:  # Only store if both name and key exist
            new_ancestry[node["key"]] = node["name"]
        
        for value in node.values():
            flatten_models(value, new_ancestry, allowed_model_list, model_info_map)
    
    elif isinstance(node, list):
        for item in node:
            flatten_models(item, ancestry, allowed_model_list, model_info_map)

    return model_info_map
